# 杂记

- ## galera集群

mysql 高可用

Active-Active架构 多主集群

同步复制 多线程复制 热备份

重启分为全量和增量复制库

原生mysql接口

每一次提交就是一个新的commit，有点类似于git，然后同步这个操作，如果所有节点都通过了这个认证尝试，就应用上去，如果没有就回滚，事务成功之后，是创建事务的节点对客户端回复成功认证

每个事务会有一个全局的事务序号，类似序列号一样的，在commit阶段就是把这个序列号的事务交给所有节点进行认证，认证通过才会commit

复制分为

- *State Snapshot Transfers (SST)* 全量复制，快照复制的感觉
- *Incremental State Transfers (IST)* 增量复制，比较相差的事务进行复制

***

- ## corosync+pacemaker 高可用集群

Corosync是一个实现HA(high Avaliable)心跳信息传输的一个软件，它可以通过一个简单的配置文件来定义信息传递的方式和协议等，实现节点间心跳传输服务。

pacemaker是一个开源的高可用资源管理器(CRM)，位于HA集群架构中资源管理、资源代理(RA)这个层次，它不能提供底层心跳信息传递的功能，要想与对方节点通信需要借助底层的心跳传递服务，将信息通告给对方。

***

- ## Quorum机制

分布式存储时使用的一种投票算法，用来保证数据冗余和最终一致性

在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。

该算法可以保证同一份数据对象的多份拷贝不会被超过两个访问对象读写。

算法来源于[Gifford, 1979]。 分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：

Vr + Vw > V
Vw > V/2
第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须要获得Vw个冗余拷贝的许可。而剩下的数量是V-Vw 不够Vr，因此不能再有读请求过来了。同理，当读请求已经获得了Vr个冗余拷贝的许可时，写请求就无法获得许可了。

第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。

***

- ## 拜占庭将军问题

拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。

在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。

***

- ## Paxos

Paxos算法是莱斯利·兰伯特（英语：Leslie Lamport，LaTeX中的“La”）于1990年提出的一种基于消息传递且具有高度容错特性的共识（consensus）算法。

需要注意的是，Paxos常被误称为“一致性算法”。但是“一致性（consistency）”和“共识（consensus）”并不是同一个概念。Paxos是一个共识（consensus）算法。

Paxos算法只是一个共识算法

Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner)：

- *Proposer*: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。

- *Acceptor*: 参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。

- *Learner*: 不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。

### 1. Basic Paxos

经典的 ***Paxos*** 算法，这个算法可以用来确单个值，也是最基础的 ***Paxos*** 算法，业务中多使用的是[Multi-Paxos算法](###Multi-Paxos).

#### 1.1 Prepare(准备)阶段

此阶段是为了统一一个最大的提案提出。

*Proposer*提出议案N（议案编号）前，需要给至多数的*Acceptor*发送`Prepare(N)`请求。

*Acceptor*接收到*Proposer*发送的`Prepare(N)`之后进入一下流程：

1. 如果接受过N号提案，则返回之前接受的N号提案的内容。

2. 如果之前接受过的最大提案号M(记作M)大于N，则忽略N号提案，或者返回一个错误，表示不接受这个请求。

3. 如果之前接受过的最大提案号M(记作M)小于N，则将最大的提案号更新为N，且记录下N的提案，并且返回成功(Accept)。

```go
// Proposer

for _,acceptor := range MaxAcceptors {
  SendPrepare(N,proposalN)
}

// Acceptor
if proposal,ok := proposals[N];ok {
  return Reply(proposal)
}

if maxProposalNum > N {
  return Reply(ErrRecvOtherProposal)
} else {
  maxProposalNum = N
  proposals[N] = proposalN
  return Reply(AcceptProposalN)
}

```

#### 1.2 Propose(提交) -- Accept(确认)阶段 -- Learn(学习)阶段

此阶段是正式提出一个提案给大多数的*Acceptor*进行`Accept`请求，同时得到正式的`Accept`回复。

*Proposer* 在[prepare阶段####Prepare(准备)阶段)如果收到了大于自己提案号的已经被接受的提案则更新自己现有的提案，最后作为最终提案N(记做N)提出，向至多数(可与上阶段不同)的*Acceptor*正式发出`Accept(N)`请求。

*Acceptor* 在收到`Accept(N)`请求后会检查自己的最大的提案号，因为在[prepare阶段](####Prepare(准备)阶段)收到`Prepare(N)`请求的*Acceptor*已经承诺过不会再*ACCEPT*小于N的提案号的请求，如果大于或者等于自己的最大提案号则通知所有的*Learner*`ACCEPT_N`，当至多数的*Acceptor*`ACCEPT_N`之后，表明N号提案被确定了，*Learner*开始学习N号提案。

当一个提案被*Learner*学习后一个提案的流程正式结束，表明被采纳。

```go
// Proposer
for _,recvProposal := range Recv {
  if recvProposal.Err != nil { // 一般这种错误都是没有被接受或者什么的，自己做处理 伪代码
    continue
  }
  if recvProposal > N {
    N = recvProposal
    proposalN = recvProposal
  }
}

for _,acceptor range MaxAcceptors {
  SendPropose(N,proposalN)
}

// Acceptor
if maxProposalNum > N {
  Reply(ErrRecvMaxNum)
}
if maxProposalNum == N {
  for _,learner := range AllLearners {
    SendAccept(ACCEPT,N,proposalN)
  }
}

// Learner

count := recvAcceptProposal[N]
if count+1 > HalfNumOfAcceptor {
  Learn(N,proposalN)
} else {
  recvAcceptProposal[N] = count + 1
}

```

#### 1.3 编号生成

具体的提案编号的生成可以采取多种方式，比如用第三方服务来生成递增编号，或者用以下方式生成：

1. 质数算法：每个 proposer 对应着唯一的质数，每个新增议案，就是该质数的倍数。比如有两个 proposer 对应着 2，3 两个质数，第一个 proposer 提出第 i 个议案时，它的编号时 2 * i 。

2. 等差算法：假设有 n 个 proposer，那么第 m 个 proposer第 i 次新增的议案编号是 m + i * n 。

### 2. Multi-Paxos算法


***

- ## Raft

Raft是一种用于替代[Paxos](##Paxos)的共识算法。

***

- ## 名词解释

  - RoundRobin: 轮询
